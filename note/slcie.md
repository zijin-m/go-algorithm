# Slice

# 数据结构
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
# 创建

`make([]int, 5, 10)` 创建一个长度为5容量为10的切片

# 扩容

使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。

扩容容量的选择大体遵循以下规则：

* 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；
* 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍

以上说法不完全正确，因为这里其实还涉及到内存对齐，详见 https://qcrao91.gitbook.io/go/shu-zu-he-qie-pian/qie-pian-de-rong-liang-shi-zen-yang-zeng-chang-de
```go
s := []int{1,2}
s = append(s,4,5,6)
fmt.Printf("%d %d",len(s),cap(s)) // 5, 6
```
上面代码的运行结果就是
```
len=5, cap=6
```
原因
```
// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
    doublecap := newcap + newcap
    if cap > doublecap {
        newcap = cap
    } else {
        // ……
    }
    // ……

    capmem = roundupsize(uintptr(newcap) * ptrSize)
    newcap = int(capmem / ptrSize)
}
```
```go
var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31}

var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
```
调用了 roundupsize 函数，传入 40,获取 size_to_class8 数组中索引为 5 的元素为 4；获取 class_to_size 中索引为 4 的元素为 48

使用append()向Slice添加一个元素的实现步骤如下：

* 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice
* 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice
* 将新元素追加进新Slice，Slice.len++，返回新的Slice

# Tips
* 创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；
* 切片拷贝时需要判断实际拷贝的元素个数
* 谨慎使用多个切片操作同一个数组，以防读写冲突
* 每个切片都指向一个底层数组
* 每个切片都保存了当前切片的长度、底层数组可用容量
* 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片
* 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片
* 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已
* 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片